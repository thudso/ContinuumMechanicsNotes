<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.52">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>kinematics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-kinematics" id="toc-sec-kinematics" class="nav-link active" data-scroll-target="#sec-kinematics">Kinematics</a>
  <ul class="collapse">
  <li><a href="#preliminaries" id="toc-preliminaries" class="nav-link" data-scroll-target="#preliminaries">Preliminaries</a></li>
  <li><a href="#configurations-and-deformations" id="toc-configurations-and-deformations" class="nav-link" data-scroll-target="#configurations-and-deformations">Configurations and deformations</a></li>
  <li><a href="#measures-of-strain" id="toc-measures-of-strain" class="nav-link" data-scroll-target="#measures-of-strain">Measures of strain</a>
  <ul class="collapse">
  <li><a href="#the-deformation-gradient" id="toc-the-deformation-gradient" class="nav-link" data-scroll-target="#the-deformation-gradient">The deformation gradient</a></li>
  <li><a href="#the-cauchygreen-strain-tensor" id="toc-the-cauchygreen-strain-tensor" class="nav-link" data-scroll-target="#the-cauchygreen-strain-tensor">The Cauchy–Green strain tensor</a></li>
  <li><a href="#rigid-deformations" id="toc-rigid-deformations" class="nav-link" data-scroll-target="#rigid-deformations">Rigid deformations</a></li>
  <li><a href="#the-infinitesimal-strain-tensor" id="toc-the-infinitesimal-strain-tensor" class="nav-link" data-scroll-target="#the-infinitesimal-strain-tensor">The infinitesimal strain tensor</a></li>
  <li><a href="#infinitesimal-rigid-deformations" id="toc-infinitesimal-rigid-deformations" class="nav-link" data-scroll-target="#infinitesimal-rigid-deformations">Infinitesimal rigid deformations</a></li>
  </ul></li>
  <li><a href="#motion" id="toc-motion" class="nav-link" data-scroll-target="#motion">Motion</a>
  <ul class="collapse">
  <li><a href="#material-and-spatial-fields" id="toc-material-and-spatial-fields" class="nav-link" data-scroll-target="#material-and-spatial-fields">Material and spatial fields</a></li>
  <li><a href="#derivatives" id="toc-derivatives" class="nav-link" data-scroll-target="#derivatives">Derivatives</a></li>
  <li><a href="#velocity-and-acceleration-fields" id="toc-velocity-and-acceleration-fields" class="nav-link" data-scroll-target="#velocity-and-acceleration-fields">Velocity and acceleration fields</a></li>
  </ul></li>
  <li><a href="#rate-of-strain-and-spin" id="toc-rate-of-strain-and-spin" class="nav-link" data-scroll-target="#rate-of-strain-and-spin">Rate of strain and spin</a>
  <ul class="collapse">
  <li><a href="#vorticity" id="toc-vorticity" class="nav-link" data-scroll-target="#vorticity">Vorticity</a></li>
  <li><a href="#rigid-motion" id="toc-rigid-motion" class="nav-link" data-scroll-target="#rigid-motion">Rigid motion</a></li>
  </ul></li>
  <li><a href="#change-of-variables" id="toc-change-of-variables" class="nav-link" data-scroll-target="#change-of-variables">Change of variables</a>
  <ul class="collapse">
  <li><a href="#transformation-of-volume-integrals" id="toc-transformation-of-volume-integrals" class="nav-link" data-scroll-target="#transformation-of-volume-integrals">Transformation of volume integrals</a></li>
  <li><a href="#derivatives-of-time-dependent-integrals" id="toc-derivatives-of-time-dependent-integrals" class="nav-link" data-scroll-target="#derivatives-of-time-dependent-integrals">Derivatives of time-dependent integrals</a></li>
  <li><a href="#transformation-of-surface-integrals" id="toc-transformation-of-surface-integrals" class="nav-link" data-scroll-target="#transformation-of-surface-integrals">Transformation of surface integrals</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<div class="hidden">
<p>$$ </p>
<p>$$</p>
</div>
<section id="sec-kinematics" class="level1">
<h1>Kinematics</h1>
<section id="preliminaries" class="level2">
<h2 class="anchored" data-anchor-id="preliminaries">Preliminaries</h2>
<p>Kinematics is the study of describing motion independently of considering mass, forces and stress. We describe the notion of strain in a body which changes shape over time. In the remainder of the module, we will discuss particular relationships between stress and strain which characterise different types of materials.</p>
<p><strong>Aims.</strong> By the end of this chapter, you should be able to:</p>
<ul>
<li><p>Define and geometrically interpret the <em>deformation gradient</em>, <em>Cauchy-Green strain tensor</em>, and the <em>infinitesimal strain tensor</em>.</p></li>
<li><p>Use the concept of a <em>motion</em> to describe the change in a body.</p></li>
<li><p>Describe the relationship between <em>material</em> and <em>spatial fields</em>.</p></li>
<li><p>Define the <em>total time derivative</em> of material and spatial fields.</p></li>
<li><p>Define the <em>velocity</em>, <em>acceleration</em>, <em>vorticity</em>, <em>rate of strain</em> and <em>spin</em> fields.</p></li>
<li><p>Explain how volume and surface integrals of fields transform and change due to motion thanks to <em>change of variables formulae</em> and the <em>Reynolds Transport Theorem</em>.</p></li>
</ul>
</section>
<section id="configurations-and-deformations" class="level2">
<h2 class="anchored" data-anchor-id="configurations-and-deformations">Configurations and deformations</h2>
<p>At any particular time, a material body occupies an open subset <span class="math inline">B\subseteq{\mathbb{E}}^3</span>, as discussed in <strong>?@sec-mass-forces</strong>. The identification of material particles with point of <span class="math inline">B</span> defines what is called a <em>configuration</em> of the body.</p>
<p>A <em>deformation</em> is a mapping between two configurations, usually a fixed region <span class="math inline">B</span> called the <em>reference configuration</em> and another varying configuration <span class="math inline">B'</span> called the <em>deformed configuration</em>. We will denote points in <span class="math inline">B</span> by <span class="math inline">{\boldsymbol{x}}</span>, and points in <span class="math inline">B'</span> by <span class="math inline">{\boldsymbol{y}}</span>. If we view <span class="math inline">B</span> and <span class="math inline">B'</span> as two configurations of the same material body, we expect that there is a one-to-one correspondence between points in the two configurations.</p>
<p>This leads us naturally to the idea of the deformation map. We will describe the mapping from <span class="math inline">B</span> to <span class="math inline">B'</span> by a function <span class="math inline">{\boldsymbol{y}}:B\to B'</span> which maps each point <span class="math inline">{\boldsymbol{x}}</span> to a point <span class="math inline">{\boldsymbol{y}}({\boldsymbol{x}})\in B'</span>. The displacement of a material particle from its initial location <span class="math inline">{\boldsymbol{x}}</span> to final location <span class="math inline">{\boldsymbol{y}}({\boldsymbol{x}})</span> is <span class="math display">{\boldsymbol{u}}({\boldsymbol{x}}) = {\boldsymbol{y}}({\boldsymbol{x}})-{\boldsymbol{x}}.</span> We call <span class="math inline">{\boldsymbol{u}}:B\to{\mathcal{V}}</span> the <em>displacement field</em> associated to <span class="math inline">{\boldsymbol{y}}</span>.</p>
<p>We will assume that deformation maps satisfy the following two important conditions:</p>
<ul>
<li><p><span class="math inline">{\boldsymbol{y}}:B\to B'</span> is one-to-one, and</p></li>
<li><p><span class="math inline">\det\nabla{\boldsymbol{y}}({\boldsymbol{x}})&gt;0</span> for all <span class="math inline">{\boldsymbol{x}}\in B</span>.</p></li>
</ul>
<p>Deformations satisfying both of these assumptions will be called <em>admissible deformations</em>. The first of these assumptions means that two material particles cannot occupy the same location, and the second ensures that a body cannot be continuously mapped onto its own mirror image. Note that the first assumption is sufficient to ensure that <span class="math inline">{\boldsymbol{y}}</span> is a bijection between <span class="math inline">B</span> and <span class="math inline">B'</span>.</p>
<p>Throughout, we will assume that all deformations are admissible, and that all are smooth enough to allow us to justify the operations of differentiation we need. Finding (and guaranteeing) that these assumptions hold in particular cases are the topic of active research.</p>
</section>
<section id="measures-of-strain" class="level2">
<h2 class="anchored" data-anchor-id="measures-of-strain">Measures of strain</h2>
<p>Consider the open ball <span class="math inline">\Omega</span> of radius <span class="math inline">\delta</span> centred at <span class="math inline">{\boldsymbol{x}}_0</span> within the body we consider. Under the deformation <span class="math inline">{\boldsymbol{y}}</span>, <span class="math inline">{\boldsymbol{x}}_0</span> is mapped to <span class="math inline">{\boldsymbol{y}}_0={\boldsymbol{y}}({\boldsymbol{x}}_0)</span>, and <span class="math inline">\Omega_\delta</span> is mapped to a region <span class="math inline">\Omega'={\boldsymbol{y}}(\Omega)</span>. Any difference in shaped between <span class="math inline">\Omega'</span> and <span class="math inline">\Omega</span> as <span class="math inline">\delta\to0</span> is called <em>strain</em> at <span class="math inline">{\boldsymbol{x}}_0</span>. Strain refers to the local stretching of a body induced by the deformation <span class="math inline">{\boldsymbol{y}}</span>. The concept of strain plays a central roles in modelling solid materials.</p>
<section id="the-deformation-gradient" class="level3">
<h3 class="anchored" data-anchor-id="the-deformation-gradient">The deformation gradient</h3>
<p>One way to quantify strain is through the <em>deformation gradient</em>, a second-order tensor field <span class="math inline">{\boldsymbol{F}}:B\to{\mathcal{V}}^2</span> defined to be <span class="math display">{\boldsymbol{F}}({\boldsymbol{x}}) = \nabla {\boldsymbol{y}}({\boldsymbol{x}}).</span> The field <span class="math inline">{\boldsymbol{F}}</span> naturally provides information on the local behaviour of <span class="math inline">{\boldsymbol{y}}</span>, since Taylor expanding, we see <span class="math display">{\boldsymbol{y}}({\boldsymbol{x}}) = {\boldsymbol{y}}({\boldsymbol{x}}_0) +{\boldsymbol{F}}({\boldsymbol{x}}_0)({\boldsymbol{x}}-{\boldsymbol{x}}_0)+{O}\big(|{\boldsymbol{x}}-{\boldsymbol{x}}_0|^2\big),</span> or equivalently <span class="math display">{\boldsymbol{y}}({\boldsymbol{x}}) = {\boldsymbol{c}}+{\boldsymbol{F}}({\boldsymbol{x}}_0){\boldsymbol{x}}+{O}\big(|{\boldsymbol{x}}-{\boldsymbol{x}}_0|^2\big)\quad\text{where}\quad {\boldsymbol{c}}= {\boldsymbol{y}}({\boldsymbol{x}}_0)-{\boldsymbol{F}}({\boldsymbol{x}}_0){\boldsymbol{x}}_0.</span></p>
<p>To understand better how <span class="math inline">{\boldsymbol{F}}</span> measures strain, suppose for simplicity that <span class="math inline">{\boldsymbol{y}}</span> is <em>homogeneous</em>, which means the deformation gradient field is constant, i.e.&nbsp;<span class="math display">{\boldsymbol{y}}({\boldsymbol{x}}) = {\boldsymbol{c}}+ {\boldsymbol{F}}{\boldsymbol{x}},</span> so the deformation is an <em>affine map</em>. We note that by virtue of this affine nature, any line segment in the reference configuration <span class="math inline">B</span> is mapped onto a corresponding line segment in the deformed configuration <span class="math inline">B'</span>.</p>
<p>We also remark that the admissibility conditions we require of deformations imply that <span class="math inline">\det\nabla{\boldsymbol{y}}({\boldsymbol{x}})&gt;0</span>, which ensures that <span class="math inline">\det{\boldsymbol{F}}&gt;0</span>, so <span class="math inline">{\boldsymbol{F}}</span> is invertible.</p>
<section id="translations-and-fixed-points" class="level4">
<h4 class="anchored" data-anchor-id="translations-and-fixed-points">Translations and fixed points</h4>
<p>A homogeneous deformation <span class="math inline">{\boldsymbol{y}}</span> is called a translation if <span class="math inline">{\boldsymbol{F}}={\boldsymbol{I}}</span>, i.e.&nbsp;<span class="math display">{\boldsymbol{y}}({\boldsymbol{x}}) = {\boldsymbol{x}}+{\boldsymbol{c}}\quad\text{for some fixed }{\boldsymbol{c}}\in{\mathcal{V}}.</span> Under such a deformation, all points in <span class="math inline">B'</span> are simply moved through a displacement <span class="math inline">{\boldsymbol{c}}</span>, so there is no change in shape or orientation of the body.</p>
<p>A homogeneous deformation has a fixed point at <span class="math inline">{\boldsymbol{x}}'</span> if <span id="eq-defFixedPoint"><span class="math display">
  {\boldsymbol{y}}({\boldsymbol{x}}) = {\boldsymbol{x}}'+ {\boldsymbol{F}}({\boldsymbol{x}}-{\boldsymbol{x}}').
\tag{1}</span></span> The point <span class="math inline">{\boldsymbol{x}}'</span> is fixed in the sense that <span class="math inline">{\boldsymbol{y}}({\boldsymbol{x}}') = {\boldsymbol{x}}'</span>. Any other point in the body is displaced by an amount determined by <span class="math inline">{\boldsymbol{F}}</span> and the position relative to the fixed point <span class="math inline">{\boldsymbol{x}}'</span>. For such a deformation, the body can change both shape and orientation. We now define a couple of classes of homogeneous deformation with fixed points.</p>
<p>A homogeneous deformation <span class="math inline">{\boldsymbol{y}}</span> is called a <em>rotation about <span class="math inline">{\boldsymbol{x}}'</span></em> if it takes the form <span class="math display">{\boldsymbol{y}}({\boldsymbol{x}})={\boldsymbol{x}}'+{\boldsymbol{Q}}({\boldsymbol{x}}-{\boldsymbol{x}}')</span> for some rotation tensor <span class="math inline">{\boldsymbol{Q}}\in{\mathcal{V}}^2</span>. Such deformations change the orientation of the body, but not its shape.</p>
<p>A homogeneous deformation <span class="math inline">{\boldsymbol{y}}</span> is called a <em>stretch about <span class="math inline">{\boldsymbol{x}}'</span></em> if it takes the form <span class="math display">{\boldsymbol{y}}({\boldsymbol{x}})={\boldsymbol{x}}'+{\boldsymbol{S}}({\boldsymbol{x}}-{\boldsymbol{x}}')</span> for some symmetric positive definite tensor <span class="math inline">{\boldsymbol{S}}\in{\mathcal{V}}^2</span>. Under such a deformation, the orientation of the body is not changed, but it is extended by different amounts in different directions with the point <span class="math inline">{\boldsymbol{x}}'</span> remaining fixed.</p>
<p>The following result shows that an arbitrary homogeneous deformation can be expressed as a composition of a translation and deformation with a given fixed point.</p>
<div class="proposition">
<p>Let <span class="math inline">{\boldsymbol{y}}</span> be a homogeneous deformation. Then, given any point <span class="math inline">{\boldsymbol{x}}'\in{\mathbb{E}}^3</span>, we can decompose <span class="math inline">{\boldsymbol{y}}</span> as <span class="math display">{\boldsymbol{y}}= {\boldsymbol{t}}_1\circ {\boldsymbol{g}}={\boldsymbol{g}}\circ{\boldsymbol{t}}_2,</span> where <span class="math inline">{\boldsymbol{t}}_1</span> and <span class="math inline">{\boldsymbol{t}}_2</span> are translations, and <span class="math inline">{\boldsymbol{g}}</span> is a homogeneous deformation with a fixed point at <span class="math inline">{\boldsymbol{x}}'</span>. In particular: <span class="math display">{\boldsymbol{g}}({\boldsymbol{x}}) = {\boldsymbol{x}}'+{\boldsymbol{F}}({\boldsymbol{x}}-{\boldsymbol{x}}').</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>See Exercise Sheet 3.</p>
</div>
<p>We now show that an arbitrary homogeneous deformation with a fixed point can always be decomposed as a rotation and a stretch about the same fixed point, using the polar decomposition theorem.</p>
<div id="prp-stretchdecomposition" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1</strong></span> If <span class="math inline">{\boldsymbol{y}}</span> is a homogeneous deformation with a fixed point <span class="math inline">{\boldsymbol{x}}'</span> and deformation gradient <span class="math inline">{\boldsymbol{F}}</span>, let <span class="math inline">{\boldsymbol{F}}= {\boldsymbol{R}}{\boldsymbol{U}}={\boldsymbol{V}}{\boldsymbol{R}}</span> be the right and left polar decompositions of <span class="math inline">{\boldsymbol{F}}</span>. Then <span class="math inline">{\boldsymbol{y}}</span> can be decomposed as <span class="math display">{\boldsymbol{y}}= {\boldsymbol{r}}\circ {\boldsymbol{s}}_1={\boldsymbol{s}}_2\circ{\boldsymbol{r}},</span> where <span class="math inline">{\boldsymbol{r}}</span> is a rotation about <span class="math inline">{\boldsymbol{x}}'</span>, and <span class="math inline">{\boldsymbol{s}}_1</span> and <span class="math inline">{\boldsymbol{s}}_2</span> are stretches about <span class="math inline">{\boldsymbol{x}}'</span>. In particular: <span class="math display">\begin{gathered}
    {\boldsymbol{r}}({\boldsymbol{x}}) = {\boldsymbol{x}}'+{\boldsymbol{R}}({\boldsymbol{x}}-{\boldsymbol{x}}'),\quad{\boldsymbol{s}}_1({\boldsymbol{x}}) = {\boldsymbol{x}}'+{\boldsymbol{U}}({\boldsymbol{x}}-{\boldsymbol{x}}')\\
    \text{and}\quad\quad{\boldsymbol{s}}_2({\boldsymbol{x}}) = {\boldsymbol{x}}'+{\boldsymbol{V}}({\boldsymbol{x}}-{\boldsymbol{x}}').
  \end{gathered}</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>See Exercise Sheet 3.</p>
</div>
<p>We can go further in decomposing stretches, by making the following definition. A homogeneous deformation <span class="math inline">{\boldsymbol{y}}</span> is called an <em>extension</em> about <span class="math inline">{\boldsymbol{x}}'</span> in the direction of a unit vector <span class="math inline">{\boldsymbol{e}}</span> if <span class="math display">{\boldsymbol{y}}({\boldsymbol{x}}) = {\boldsymbol{x}}'+{\boldsymbol{F}}({\boldsymbol{x}}-{\boldsymbol{x}}')\quad\text{with}\quad {\boldsymbol{F}}={\boldsymbol{I}}+(\lambda-1){\boldsymbol{e}}\otimes{\boldsymbol{e}},</span> for some <span class="math inline">\lambda&gt;0</span>. This terminology is based on the observation that <span class="math inline">{\boldsymbol{F}}</span> changes the length of any vector parallel to <span class="math inline">{\boldsymbol{e}}</span> by a factor of <span class="math inline">\lambda</span>, that is <span class="math display">{\boldsymbol{F}}(\alpha{\boldsymbol{e}}) = \alpha{\boldsymbol{e}}+(\lambda-1)\alpha({\boldsymbol{e}}\cdot{\boldsymbol{e}}){\boldsymbol{e}}= \lambda\alpha{\boldsymbol{e}}</span> This is a particular case of the stretch deformation introduced earlier. The following result shows that the stretches appearing in <a href="#prp-stretchdecomposition" class="quarto-xref">Proposition&nbsp;1</a> can be expressed as the composition of three extensions defined by the eigenvalues and eigenvectors of <span class="math inline">{\boldsymbol{U}}</span> and <span class="math inline">{\boldsymbol{V}}</span>.</p>
<div class="proposition">
<p>Let <span class="math inline">{\boldsymbol{s}}_1</span> and <span class="math inline">{\boldsymbol{s}}_2</span> be the stretches defined in <a href="#prp-stretchdecomposition" class="quarto-xref">Proposition&nbsp;1</a>, and let <span class="math inline">\{\lambda_i,{\boldsymbol{u}}_i\}</span> and <span class="math inline">\{\lambda_i,{\boldsymbol{v}}_i\}</span> be the eigenpairs associated with the tensors <span class="math inline">{\boldsymbol{U}}</span> and <span class="math inline">{\boldsymbol{V}}</span> respectively. Then <span class="math display">{\boldsymbol{s}}_1 = {\boldsymbol{f}}_1\circ{\boldsymbol{f}}_2\circ{\boldsymbol{f}}_3\quad\text{and}\quad{\boldsymbol{s}}_2={\boldsymbol{h}}_1\circ{\boldsymbol{h}}_2\circ{\boldsymbol{h}}_3,</span> where <span class="math inline">{\boldsymbol{f}}_i</span> is the extension about <span class="math inline">{\boldsymbol{x}}'</span> by <span class="math inline">\lambda_i</span> in the direction <span class="math inline">{\boldsymbol{u}}_i</span>, and <span class="math inline">{\boldsymbol{h}}_i</span> is the extension about <span class="math inline">{\boldsymbol{x}}'</span> by <span class="math inline">\lambda_i</span> in the direction <span class="math inline">{\boldsymbol{v}}_i</span>.</p>
</div>
<p><strong>Exercise:</strong> Prove this result.</p>
<p>Notes:</p>
<ol type="1">
<li><p>The tensors <span class="math inline">{\boldsymbol{U}}</span> and <span class="math inline">{\boldsymbol{V}}</span> which appear in the right and left polar decompositions of <span class="math inline">{\boldsymbol{F}}</span> have the same eigenvalues, but (in general) have different eigenvectors. It follows that <span class="math inline">{\boldsymbol{s}}_1</span> and <span class="math inline">{\boldsymbol{s}}_2</span> give rise to extensions by the same amounts, but in different directions.</p></li>
<li><p>We call the eigenvalues <span class="math inline">\lambda_i</span> the <em>principal stretches</em> associated with the deformation gradient <span class="math inline">{\boldsymbol{F}}</span>, and the eigenvectors <span class="math inline">{\boldsymbol{u}}_i</span> and <span class="math inline">{\boldsymbol{v}}_i</span> are respectively referred to as the right and left <em>principal directions</em>. Similarly, we call <span class="math inline">{\boldsymbol{U}}</span> and <span class="math inline">{\boldsymbol{V}}</span> the right and left <em>stretch tensors</em>.</p></li>
</ol>
<p>In summary, we have shown that a homogeneous deformation can be decomposed in various ways, for example as a translation, then a rotation, then a series of extensions, or as a translation, then a series of extensions, and then a rotation. These different decompositions allow us to think about how a body might be affected by such a sequence of operations, and so devise physically-appropriate models, especially since a Taylor expansion of the deformation <span class="math inline">{\boldsymbol{y}}</span> allows us to treat deformations close to a given point as approximately homogeneous.</p>
</section>
</section>
<section id="the-cauchygreen-strain-tensor" class="level3">
<h3 class="anchored" data-anchor-id="the-cauchygreen-strain-tensor">The Cauchy–Green strain tensor</h3>
<p>Consider a general deformation <span class="math inline">{\boldsymbol{y}}:B\to B'</span> with deformation gradient <span class="math inline">{\boldsymbol{F}}= \nabla {\boldsymbol{y}}</span>. Another measure of strain is the <em>right Cauchy-Green strain tensor</em> field <span class="math inline">{\boldsymbol{C}}:B\to{\mathcal{V}}^2</span>, defined by <span class="math display">{\boldsymbol{C}}= {\boldsymbol{F}}^T{\boldsymbol{F}},</span> Notice that <span class="math inline">{\boldsymbol{C}}</span> is symmetric and positive definite at every point in <span class="math inline">B</span>.</p>
<p>While <span class="math inline">{\boldsymbol{F}}</span> contains information on both rotation and stretching, <span class="math inline">{\boldsymbol{C}}</span> including information about stretches only: since <span class="math inline">{\boldsymbol{F}}={\boldsymbol{R}}{\boldsymbol{U}}</span>, <span class="math display">{\boldsymbol{C}}= {\boldsymbol{F}}^T{\boldsymbol{F}}= {\boldsymbol{U}}^2,</span> we see the definition of <span class="math inline">{\boldsymbol{C}}</span> does not contain <span class="math inline">{\boldsymbol{R}}</span>.</p>
<ul>
<li><p>Note that <span class="math inline">{\boldsymbol{U}}</span> is also independent of <span class="math inline">{\boldsymbol{R}}</span>, and contains information on stretches only, but <span class="math inline">{\boldsymbol{C}}</span> is easier to compute than the square root <span class="math inline">{\boldsymbol{U}}=\sqrt{{\boldsymbol{F}}^T{\boldsymbol{F}}}=\sqrt{{\boldsymbol{C}}}</span>.</p></li>
<li><p>Recall from the Spectral Decomposition Theorem that <span class="math display">{\boldsymbol{U}}= \sum_{i=1}^3 \lambda_i{\boldsymbol{e}}_i\otimes{\boldsymbol{e}}_i,</span> where <span class="math inline">\lambda_i&gt;0</span> and <span class="math inline">{\boldsymbol{e}}_i</span> are orthonormal eigenvectors of <span class="math inline">{\boldsymbol{U}}</span>. As <span class="math inline">{\boldsymbol{C}}= {\boldsymbol{U}}^2</span>, we see that <span class="math display">{\boldsymbol{C}}= \sum_{i=1}^3 \lambda_i^2{\boldsymbol{e}}_i\otimes{\boldsymbol{e}}_i,</span> so the eigenvalues of <span class="math inline">{\boldsymbol{C}}</span> are the squares of the principal stretches.</p></li>
<li><p>Another measure of strain is the <em>left Cauchy-Green strain tensor</em>, <span class="math inline">{\boldsymbol{B}}= {\boldsymbol{F}}{\boldsymbol{F}}^T</span>. We will not use this measure here.</p></li>
</ul>
<p>We now consider the interpretation of <span class="math inline">{\boldsymbol{C}}</span>. Consider a point <span class="math inline">{\boldsymbol{x}}_0</span> in the reference configuration, and let <span class="math inline">\Omega</span> be the open ball of radius <span class="math inline">\alpha&gt;0</span> centred at <span class="math inline">{\boldsymbol{x}}_0</span>. Consider the points <span class="math inline">{\boldsymbol{x}}_1 = {\boldsymbol{x}}_0+\alpha{\boldsymbol{e}}</span> and <span class="math inline">{\boldsymbol{x}}_2={\boldsymbol{x}}_0+\alpha{\boldsymbol{d}}</span>, where <span class="math inline">{\boldsymbol{e}}</span> and <span class="math inline">{\boldsymbol{d}}</span> are unit vectors. Let <span class="math inline">{\boldsymbol{y}}_0={\boldsymbol{y}}({\boldsymbol{x}}_0)</span>, <span class="math inline">{\boldsymbol{y}}_1={\boldsymbol{y}}({\boldsymbol{x}}_1)</span> and <span class="math inline">{\boldsymbol{y}}_2={\boldsymbol{y}}({\boldsymbol{x}}_2)</span> be the corresponding points in the deformed configuration. Let <span class="math inline">\phi\in[0,\pi]</span> be the angle between <span class="math inline">{\boldsymbol{v}}={\boldsymbol{y}}_1-{\boldsymbol{y}}_0</span> and <span class="math inline">{\boldsymbol{w}}={\boldsymbol{y}}_2-{\boldsymbol{y}}_0</span>.</p>
<div id="prp-CGstrainrelations" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2</strong></span> For any point <span class="math inline">{\boldsymbol{x}}_0\in B</span> and unit vectors <span class="math inline">{\boldsymbol{e}}</span> and <span class="math inline">{\boldsymbol{d}}</span>, define <span class="math display">\lambda({\boldsymbol{e}}) = \sqrt{{\boldsymbol{e}}\cdot{\boldsymbol{C}}{\boldsymbol{e}}}&gt;0 \quad\text{and}\quad
    \theta({\boldsymbol{e}},{\boldsymbol{d}}) = \arccos\bigg(\frac{{\boldsymbol{e}}\cdot{\boldsymbol{C}}{\boldsymbol{d}}}{\sqrt{{\boldsymbol{e}}\cdot{\boldsymbol{C}}{\boldsymbol{e}}}\sqrt{{\boldsymbol{d}}\cdot{\boldsymbol{C}}{\boldsymbol{d}}}}\bigg)\in[0,\pi].</span> Then, as <span class="math inline">\alpha\to0</span>, we have that <span class="math display">\frac{|{\boldsymbol{y}}'-{\boldsymbol{y}}_0|}{|{\boldsymbol{x}}'-{\boldsymbol{x}}_0|}\to\lambda({\boldsymbol{e}}),\quad \frac{|{\boldsymbol{y}}''-{\boldsymbol{y}}_0|}{|{\boldsymbol{x}}''-{\boldsymbol{x}}_0|}\to\lambda({\boldsymbol{d}})</span> and <span class="math display">\phi\to \theta({\boldsymbol{e}},{\boldsymbol{d}}).</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Note that <span class="math inline">{\boldsymbol{v}}= {\boldsymbol{y}}({\boldsymbol{x}}_0+\alpha{\boldsymbol{e}})-{\boldsymbol{y}}({\boldsymbol{x}}_0)</span>, so Taylor expanding, we have <span class="math display">{\boldsymbol{v}}= \alpha {\boldsymbol{F}}({\boldsymbol{x}}_0){\boldsymbol{e}}+{O}(\alpha^2).</span> It follows that <span class="math display">|{\boldsymbol{v}}|^2 = \alpha^2{\boldsymbol{F}}({\boldsymbol{x}}_0){\boldsymbol{e}}\cdot{\boldsymbol{F}}({\boldsymbol{x}}_0){\boldsymbol{e}}+{O}(\alpha^3) = \alpha^2 {\boldsymbol{e}}\cdot{\boldsymbol{C}}({\boldsymbol{x}}_0){\boldsymbol{e}}+{O}(\alpha^3).</span> Dividing through by <span class="math inline">\alpha^2=|{\boldsymbol{x}}'-{\boldsymbol{x}}_0|^2</span>, and using the fact that <span class="math inline">{\boldsymbol{v}}={\boldsymbol{y}}'-{\boldsymbol{y}}_0</span>, we have <span class="math display">\frac{|{\boldsymbol{y}}'-{\boldsymbol{y}}_0|^2}{|{\boldsymbol{x}}'-{\boldsymbol{x}}_0|^2} = \frac{|{\boldsymbol{v}}|^2}{\alpha^2} = {\boldsymbol{e}}\cdot{\boldsymbol{C}}({\boldsymbol{x}}_0){\boldsymbol{e}}+{O}(\alpha),</span> which, after taking a square root, proves the first result. The second result follows by a similar argument.</p>
<p>To establish the final result, we note that <span class="math display">\cos\phi = \frac{{\boldsymbol{v}}\cdot{\boldsymbol{w}}}{|{\boldsymbol{v}}||{\boldsymbol{w}}|}.</span> Using the facts that <span class="math inline">{\boldsymbol{v}}=\alpha{\boldsymbol{F}}({\boldsymbol{x}}){\boldsymbol{e}}+{O}(\alpha^2)</span> and <span class="math inline">{\boldsymbol{w}}=\alpha{\boldsymbol{F}}({\boldsymbol{x}}){\boldsymbol{d}}+{O}(\alpha^2)</span>, we have <span class="math display">\frac{{\boldsymbol{v}}\cdot{\boldsymbol{w}}}{\alpha^2} = {\boldsymbol{e}}\cdot{\boldsymbol{C}}({\boldsymbol{x}}){\boldsymbol{d}}+{O}(\alpha).</span> Then, using <span class="math inline">|{\boldsymbol{v}}| = \alpha \lambda({\boldsymbol{e}})+{O}(\alpha^2)</span> and <span class="math inline">|{\boldsymbol{w}}|=\alpha\lambda({\boldsymbol{d}})+{O}(\alpha^2)</span>, we conclude.</p>
</div>
<p><strong>Remarks:</strong></p>
<ol type="1">
<li><p>This result states that <span class="math inline">\lambda({\boldsymbol{e}})</span> approximates the ratio of lengths between deformed points and reference points, where the reference points are separated by a short displacement in the direction <span class="math inline">{\boldsymbol{e}}</span>. This is the reason for naming <span class="math inline">\lambda({\boldsymbol{e}})</span> the <em>stretch</em> in the direction <span class="math inline">{\boldsymbol{e}}</span> at the reference point <span class="math inline">{\boldsymbol{x}}</span>.</p></li>
<li><p>At any fixed reference point <span class="math inline">{\boldsymbol{x}}</span>, the extreme values of <span class="math inline">\lambda({\boldsymbol{e}})</span> occur when <span class="math inline">{\boldsymbol{e}}</span> is an eigenvector of <span class="math inline">{\boldsymbol{C}}</span> (i.e. a right principal direction). As a result the extreme values of <span class="math inline">\lambda({\boldsymbol{e}})</span> are given by the maximum and minimum principal stretches.</p></li>
<li><p><span class="math inline">\theta({\boldsymbol{e}},{\boldsymbol{d}})</span> approximates the angle between points in the deformed configuration which lie at short distances from <span class="math inline">{\boldsymbol{x}}</span> along the directions <span class="math inline">{\boldsymbol{e}}</span> and <span class="math inline">{\boldsymbol{d}}</span>. If <span class="math inline">\Theta({\boldsymbol{e}},{\boldsymbol{d}}) = \arccos({\boldsymbol{e}}\cdot{\boldsymbol{d}})</span> is the angle between these directions in the reference configuration, we define <span class="math display">\gamma({\boldsymbol{e}},{\boldsymbol{d}}) = \Theta({\boldsymbol{e}},{\boldsymbol{d}})-\theta({\boldsymbol{e}},{\boldsymbol{d}}),</span> which we call the <em>shear</em> between the directions <span class="math inline">{\boldsymbol{e}}</span> and <span class="math inline">{\boldsymbol{d}}</span> at the point <span class="math inline">{\boldsymbol{x}}</span>. The shear measures the change in angle between directions due to deformation.</p></li>
</ol>
<p>The following result shows that <span class="math inline">{\boldsymbol{C}}</span> explicitly characterises the stretch and shear caused by a deformation.</p>
<div id="prp-stretchshear" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 3</strong></span> Let <span class="math inline">C_{ij}</span> be the components of <span class="math inline">{\boldsymbol{C}}</span> with respect to an arbitrary coordinate frame <span class="math inline">\{{\boldsymbol{e}}_i\}</span>. Then, for any point <span class="math inline">{\boldsymbol{x}}\in B</span>, we have <span class="math display">C_{ii} = \lambda({\boldsymbol{e}}_i)^2\quad\text{and}\quad C_{ij} = \lambda({\boldsymbol{e}}_i)\lambda({\boldsymbol{e}}_j)\sin\big(\gamma({\boldsymbol{e}}_i,{\boldsymbol{e}}_j)\big),</span> where no summation is implied. The diagonal components of <span class="math inline">{\boldsymbol{C}}</span> are therefore the squares of the stretches along coordinate directions, and the off-diagonal components capture the shear between corresponding pairs of coordinate directions.</p>
</div>
</section>
<section id="rigid-deformations" class="level3">
<h3 class="anchored" data-anchor-id="rigid-deformations">Rigid deformations</h3>
<p>A homogeneous deformation <span class="math inline">{\boldsymbol{y}}:B\to B'</span> is a <em>rigid deformation</em> if <span class="math display">{\boldsymbol{y}}({\boldsymbol{x}}) = {\boldsymbol{c}}+{\boldsymbol{Q}}{\boldsymbol{x}}</span> where <span class="math inline">{\boldsymbol{c}}\in{\mathcal{V}}</span> and <span class="math inline">{\boldsymbol{Q}}\in{\mathcal{V}}^2</span> is a rotation tensor. For such deformations we have <span class="math inline">{\boldsymbol{F}}={\boldsymbol{Q}}</span>, and hence <span class="math display">{\boldsymbol{C}}= {\boldsymbol{F}}^T{\boldsymbol{F}}= {\boldsymbol{Q}}^T{\boldsymbol{Q}}= {\boldsymbol{I}}.</span> It follows that rigid deformations produce no strain measured by <span class="math inline">{\boldsymbol{C}}</span>. Looking carefully at the proof of <a href="#prp-CGstrainrelations" class="quarto-xref">Proposition&nbsp;2</a>, we see that the relative position and orientation of any three points in <span class="math inline">B</span> are unchanged by a rigid deformation (hence the name). It is possible to show that a deformation is rigid if and only if <span class="math inline">{\boldsymbol{C}}({\boldsymbol{x}})={\boldsymbol{I}}</span> for all <span class="math inline">{\boldsymbol{x}}\in B</span>.</p>
</section>
<section id="the-infinitesimal-strain-tensor" class="level3">
<h3 class="anchored" data-anchor-id="the-infinitesimal-strain-tensor">The infinitesimal strain tensor</h3>
<p>Consider a deformation <span class="math inline">{\boldsymbol{y}}:B\to B'</span> with displacement field <span class="math inline">{\boldsymbol{u}}</span> and displacement gradient <span class="math inline">\nabla {\boldsymbol{u}}</span>. The <em>infinitesimal strain tensor</em> field associated with <span class="math inline">{\boldsymbol{y}}</span> is <span class="math inline">{\boldsymbol{E}}:B\to{\mathcal{V}}^2</span> defined by <span class="math display">{\boldsymbol{E}}= {\operatorname{sym}}(\nabla{\boldsymbol{u}}) = \tfrac12(\nabla{\boldsymbol{u}}+\nabla{\boldsymbol{u}}^T).</span> Note that, by definition, <span class="math inline">{\boldsymbol{E}}</span> is symmetric. We also note that in the Engineering literature, it is common to denote the infinitesimal strain tensor as <span class="math inline">\boldsymbol{\varepsilon}</span>.</p>
<p><span class="math inline">{\boldsymbol{E}}</span> is related to the deformation gradient <span class="math inline">{\boldsymbol{F}}</span> and the Cauchy-Green tensor <span class="math inline">{\boldsymbol{C}}</span>. From the definition of <span class="math inline">{\boldsymbol{u}}</span>, we see that <span class="math inline">\nabla {\boldsymbol{u}}= {\boldsymbol{F}}-{\boldsymbol{I}}</span>, and hence <span class="math inline">{\boldsymbol{E}}= {\operatorname{sym}}({\boldsymbol{F}}-{\boldsymbol{I}})</span>. Since <span class="math inline">{\boldsymbol{C}}= {\boldsymbol{F}}^T{\boldsymbol{F}}</span>, we see that <span class="math display">{\boldsymbol{E}}= \tfrac12({\boldsymbol{C}}-{\boldsymbol{I}})-\tfrac12\nabla{\boldsymbol{u}}^T\nabla {\boldsymbol{u}}.</span> The tensor <span class="math inline">{\boldsymbol{E}}</span> is particularly useful in the case of small deformations. A deformation <span class="math inline">{\boldsymbol{y}}</span> is <em>small</em> if there is a number <span class="math inline">0\leq \varepsilon\ll 1</span> such that <span class="math inline">|\nabla{\boldsymbol{u}}({\boldsymbol{x}})| = {O}(\varepsilon)</span> for all points <span class="math inline">{\boldsymbol{x}}\in B</span>, and in this case, we see that that <span class="math display">{\boldsymbol{E}}= \tfrac12({\boldsymbol{C}}-{\boldsymbol{I}})+{O}(\varepsilon^2).</span> If we drop terms of <span class="math inline">{O}(\varepsilon^2)</span>, then <span class="math inline">{\boldsymbol{E}}</span> is equivalent to <span class="math inline">{\boldsymbol{C}}</span> up to a multiplicative factor and offset, and <span class="math inline">{\boldsymbol{E}}</span> will arise when studying linearised models of stress in elastic solids.</p>
<ul>
<li><p>Note that if <span class="math inline">\nabla {\boldsymbol{u}}={\boldsymbol{O}}</span> everywhere in <span class="math inline">B</span>, we have <span class="math inline">{\boldsymbol{F}}= {\boldsymbol{I}}</span>, and hence <span class="math inline">{\boldsymbol{y}}</span> is a translation. It follows that <span class="math inline">{\boldsymbol{y}}</span> is a small deformation when it deviates only slightly from a pure translation.</p></li>
<li><p>For small deformations, the tensor <span class="math inline">{\boldsymbol{E}}</span> contains similar information to <span class="math inline">{\boldsymbol{C}}</span>. However, we note that <span class="math inline">{\boldsymbol{E}}</span> depends linearly on <span class="math inline">{\boldsymbol{u}}</span> (and hence on <span class="math inline">{\boldsymbol{y}}</span>), whereas <span class="math inline">{\boldsymbol{C}}</span> depends non-linearly on <span class="math inline">{\boldsymbol{u}}</span>.</p></li>
</ul>
<p>To interpret <span class="math inline">{\boldsymbol{E}}</span>, we have the following result.</p>
<div id="prp-Ecomponents" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4</strong></span> Let <span class="math inline">E_{ij}</span> be the components of <span class="math inline">{\boldsymbol{E}}</span> taken with respect to a Cartesian frame <span class="math inline">\{{\boldsymbol{e}}_i\}</span>. Then, with no sum over repeated indices implies, we have <span class="math display">E_{ii} =\lambda({\boldsymbol{e}}_i)-1+{O}(\varepsilon^2)\quad\text{and}\quad
    E_{ij} =\tfrac12\sin\gamma({\boldsymbol{e}}_i,{\boldsymbol{e}}_j)+{O}(\varepsilon^2),</span> where <span class="math inline">\lambda({\boldsymbol{e}}_i)</span> is the stretch in the direction <span class="math inline">{\boldsymbol{e}}_i</span>, and <span class="math inline">\gamma({\boldsymbol{e}}_i,{\boldsymbol{e}}_j)</span> is the shear between the directions <span class="math inline">{\boldsymbol{e}}_i</span> and <span class="math inline">{\boldsymbol{e}}_j</span>.</p>
</div>
<p>This result can be proven using <a href="#prp-stretchshear" class="quarto-xref">Proposition&nbsp;3</a>.</p>
<p><strong>Notes:</strong></p>
<ul>
<li><p>As shown in <a href="#prp-CGstrainrelations" class="quarto-xref">Proposition&nbsp;2</a>, the stretch <span class="math inline">\lambda({\boldsymbol{e}}_i)</span> is the ratio of the distance between deformed points which were close to one another in the <span class="math inline">{\boldsymbol{e}}_i</span> direction in the reference configuration. This means that <span class="math inline">\lambda({\boldsymbol{e}}_i)-1</span> is approximately the relative change in the length of an infinitesimal line segment pointing in the <span class="math inline">{\boldsymbol{e}}_i</span> direction in the reference configuration.</p></li>
<li><p>When the shear angle <span class="math inline">\gamma({\boldsymbol{e}}_i,{\boldsymbol{e}}_j)</span> is small, we have that <span class="math display">E_{ij}\approx \tfrac12\sin\gamma({\boldsymbol{e}}_i,{\boldsymbol{e}}_j)\approx \tfrac12\gamma({\boldsymbol{e}}_i,{\boldsymbol{e}}_j),</span> so for small deformations, the off-diagonal components of <span class="math inline">{\boldsymbol{E}}</span> are approximately half the shear angle between to line segments which pointed in the directions <span class="math inline">{\boldsymbol{e}}_i</span> and <span class="math inline">{\boldsymbol{e}}_j</span> in the reference configuration.</p></li>
</ul>
</section>
<section id="infinitesimal-rigid-deformations" class="level3">
<h3 class="anchored" data-anchor-id="infinitesimal-rigid-deformations">Infinitesimal rigid deformations</h3>
<p>A homogeneous deformation <span class="math inline">{\boldsymbol{y}}</span> is called <em>infinitesimally rigid</em> if the associated displacement field <span class="math inline">{\boldsymbol{u}}</span> takes the form <span class="math display">{\boldsymbol{u}}({\boldsymbol{x}}) = {\boldsymbol{c}}+{\boldsymbol{W}}{\boldsymbol{x}}</span> for some vector <span class="math inline">{\boldsymbol{c}}\in{\mathcal{V}}</span> and a skew-symmetric tensor <span class="math inline">{\boldsymbol{W}}\in{\mathcal{V}}^2</span>. Recalling the result of <strong>?@prp-skewtensorvectorproduct</strong>, we may write <span class="math display">{\boldsymbol{u}}({\boldsymbol{x}}) = {\boldsymbol{c}}+{\boldsymbol{w}}\times{\boldsymbol{x}}</span> where <span class="math inline">{\boldsymbol{w}}</span> is the axial vector of <span class="math inline">{\boldsymbol{W}}</span>. For an infinitesimally rigid deformation, the displacement gradient is <span class="math inline">\nabla {\boldsymbol{u}}= {\boldsymbol{W}}</span>, and <span class="math display">{\boldsymbol{E}}= {\operatorname{sym}}(\nabla{\boldsymbol{u}}) = \tfrac12({\boldsymbol{W}}+{\boldsymbol{W}}^T) = {\boldsymbol{O}}.</span> As a result, we see that infinitesimal rigid deformations produce no strain measured by <span class="math inline">{\boldsymbol{E}}</span>.</p>
</section>
</section>
<section id="motion" class="level2">
<h2 class="anchored" data-anchor-id="motion">Motion</h2>
<p>The continuous deformation of a body over time is called a <em>motion</em>. The motion of a body with reference configuration <span class="math inline">B</span> can be described by a continuous map <span class="math inline">{\boldsymbol{\varphi}}:B\times[0,T]\to{\mathbb{E}}^3</span>, where for any fixed time <span class="math inline">t</span>, the function <span class="math inline">{\boldsymbol{\varphi}}(\cdot,t):B\to{\mathbb{E}}^3</span> is a deformation of <span class="math inline">B</span>. At time <span class="math inline">t</span>, the body undergoing this motion is in the configuration <span class="math inline">B_t = {\boldsymbol{\varphi}}(B,t)</span>, and we call <span class="math inline">B_t</span> the <em>current</em> or <em>deformed</em> configuration at time <span class="math inline">t</span>.</p>
<p>If <span class="math inline">{\boldsymbol{\varphi}}(\cdot,0)</span> is the identity map, i.e.&nbsp;<span class="math inline">{\boldsymbol{\varphi}}({\boldsymbol{x}},0) = {\boldsymbol{x}}</span> for all <span class="math inline">{\boldsymbol{x}}\in B</span>, we have that <span class="math inline">B_0=B</span>. Assuming continuity ensures that the body cannot break apart into pieces, and cannot move by an instantaneous jump. We will assume that <span class="math inline">{\boldsymbol{\varphi}}(\cdot,t)</span> is admissible in the sense described above, and hence there exists an inverse deformation <span class="math inline">{\boldsymbol{\psi}}(\cdot,t):B_t\to B</span> with <span class="math inline">{\boldsymbol{\psi}}(\cdot,t)={\boldsymbol{\varphi}}^{-1}(\cdot,t)</span>, i.e. <span class="math inline">{\boldsymbol{\psi}}({\boldsymbol{\varphi}}({\boldsymbol{x}},t),t) = {\boldsymbol{x}}</span>.</p>
<p>Throughout the remainder of this module, we will assume that all motions and their inverses are smooth in the sense that partial derivatives of all orders used exist and are continuous.</p>
<section id="material-and-spatial-fields" class="level3">
<h3 class="anchored" data-anchor-id="material-and-spatial-fields">Material and spatial fields</h3>
<p>In our study of the motion of continuum bodies, we wish to study fields defined on the current configuration <span class="math inline">B_t</span>, whose points we label <span class="math inline">{\boldsymbol{y}}</span>. Since we assume such points can be expressed in terms of the deformation mapping <span class="math inline">{\boldsymbol{y}}={\boldsymbol{\varphi}}({\boldsymbol{x}},t)</span>, any function defined on <span class="math inline">B_t</span> can also be expressed as a function of <span class="math inline">B</span> through ‘pre-composition’ with the motion <span class="math inline">{\boldsymbol{\varphi}}:B\times[0,T]\to{\mathbb{E}}^3</span>, and any function defined on the reference configuration <span class="math inline">B</span> can be expressed as a function defined on <span class="math inline">B_t</span> through precomposition with the inverse mapping <span class="math inline">{\boldsymbol{\psi}}(\cdot,t) : B_t\to{\mathbb{E}}^3</span>.</p>
<p>By a <em>material field</em>, we mean a field which is expressed in terms of the points <span class="math inline">{\boldsymbol{x}}\in B</span>; for example <span class="math inline">\Omega=\Omega({\boldsymbol{x}},t)</span> for <span class="math inline">{\boldsymbol{x}}\in B</span>. By a <em>spatial field</em>, we mean a field expressed in terms of the point <span class="math inline">{\boldsymbol{y}}\in B_t</span>, for example <span class="math inline">\Gamma=\Gamma({\boldsymbol{y}},t)</span> for <span class="math inline">{\boldsymbol{y}}\in B_t</span>.</p>
<p>We can freely map back and forth between these descriptions. To any material field <span class="math inline">\Omega({\boldsymbol{x}},t)</span>, we can associate a spatial field <span class="math display">\Omega_s({\boldsymbol{y}},t) = \Omega({\boldsymbol{\psi}}({\boldsymbol{y}},t),t).</span> We call <span class="math inline">\Omega_s</span> the <em>spatial description</em> of the material field <span class="math inline">\Omega</span>. Likewise, given a spatial field <span class="math inline">\Gamma({\boldsymbol{y}},t)</span>, we can define an associated material field <span class="math display">\Gamma_m({\boldsymbol{x}},t) = \Gamma({\boldsymbol{\varphi}}({\boldsymbol{x}},t),t),</span> and we refer to <span class="math inline">\Gamma_m</span> as the material description of the spatial field <span class="math inline">\Gamma</span>.</p>
</section>
<section id="derivatives" class="level3">
<h3 class="anchored" data-anchor-id="derivatives">Derivatives</h3>
<p>Given that we have two different descriptions of the fields of interest, we need to distinguish differentiation with respect to the material coordinates <span class="math inline">{\boldsymbol{x}}= (x_1,x_2,x_3)</span> labelling points in <span class="math inline">B</span>, and the spatial coordinates <span class="math inline">{\boldsymbol{y}}=({\boldsymbol{y}}_1,{\boldsymbol{y}}_2,{\boldsymbol{y}}_3)</span>, labelling points in <span class="math inline">B_t</span>.</p>
<p>To keep these derivatives separate, we use <span class="math inline">\nabla_{\boldsymbol{x}}</span> to refer to the gradient, divergence and curl taken in the material coordinates, and <span class="math inline">\nabla_{\boldsymbol{y}}</span> to refer to the gradient, divergence and curl taken in the spatial coordinates.</p>
<p>We will also frequently compute the rate of change of a field with respect to time. The <em>total time derivative</em> or <em>convective derivative</em> of a field is the rate of change of a field as measured by a stationary observer who is tracking the motion of each particle in the body. Since we keep the reference configuration <span class="math inline">B</span> fixed, it follows that the material coordinates <span class="math inline">{\boldsymbol{x}}\in B</span> of each particle are fixed. On the other hand, as the current configuration varies in time, the spatial coordinates <span class="math inline">{\boldsymbol{y}}\in B_t</span> will change with time.</p>
<p>We note that any material field <span class="math inline">\Omega({\boldsymbol{x}},t)</span> satisfies <span class="math display">\DDt{}\Omega({\boldsymbol{x}},t)=\frac{\partial}{\partial t}\Omega({\boldsymbol{x}},t),</span> where as for a spatial field <span class="math inline">\Gamma({\boldsymbol{y}},t)</span>, we have <span class="math display">\DDt{}\Gamma({\boldsymbol{y}},t) = \frac{\partial}{\partial t}\Gamma\big({\boldsymbol{\varphi}}({\boldsymbol{x}},t),t\big)\bigg|_{{\boldsymbol{x}}={\boldsymbol{\psi}}({\boldsymbol{y}},t)}= \frac{\partial}{\partial t}\Gamma_m({\boldsymbol{x}},t)\bigg|_{{\boldsymbol{x}}={\boldsymbol{\psi}}({\boldsymbol{y}},t)}.</span> We can write this as <span class="math display">\DDt\Gamma = \left[\DDt{\Gamma_m}\right]_s.</span></p>
<p><strong>Remarks:</strong></p>
<ul>
<li><p>The total time derivative of a field is sometimes called the <em>material</em>, <em>substantial</em>, or <em>convective</em> derivative.</p></li>
<li><p>In general, we note that <span class="math inline">\DDt{\Gamma}({\boldsymbol{y}},t)\neq \frac{\partial}{\partial t}\Gamma({\boldsymbol{y}},t)</span>, i.e.&nbsp;the total time derivative and partial time derivative of a spatial field are not the same. This distinction arises since the partial derivative treats spatial coordinates as fixed, but the time derivative takes into account the motion of the coordinates themselves as they follow a given particle.</p></li>
</ul>
</section>
<section id="velocity-and-acceleration-fields" class="level3">
<h3 class="anchored" data-anchor-id="velocity-and-acceleration-fields">Velocity and acceleration fields</h3>
<p>Consider a motion <span class="math inline">{\boldsymbol{\varphi}}</span>, and consider a particle <span class="math inline">{\boldsymbol{x}}\in B</span>. At later times, the particle has position <span class="math inline">{\boldsymbol{y}}= {\boldsymbol{\varphi}}({\boldsymbol{x}},t)\in B_t</span>. The velocity of this particle and its acceleration both labelled by its material coordinates, are <span class="math display">\frac{\partial}{\partial t}{\boldsymbol{\varphi}}({\boldsymbol{x}},t)\quad\text{and}\quad
  \frac{\partial^2}{\partial t^2}{\boldsymbol{\varphi}}({\boldsymbol{x}},t).</span> By definition, these are both material fields, but we will also wish to consider the spatial description of these fields. Setting <span class="math inline">{\boldsymbol{v}}</span> and <span class="math inline">{\boldsymbol{a}}</span> to be the spatial forms of these fields, we have <span class="math display">{\boldsymbol{v}}({\boldsymbol{y}},t) = \frac{\partial}{\partial t}{\boldsymbol{\varphi}}({\boldsymbol{x}},t)\bigg|_{{\boldsymbol{x}}={\boldsymbol{\psi}}({\boldsymbol{y}},t)}\quad\text{and}\quad
  {\boldsymbol{a}}({\boldsymbol{y}},t) = \frac{\partial^2}{\partial t^2}{\boldsymbol{\varphi}}({\boldsymbol{x}},t)\bigg|_{{\boldsymbol{x}}={\boldsymbol{\psi}}({\boldsymbol{y}},t)}.</span> These two fields correspond to the velocity and acceleration of a particle whose spatial position is <span class="math inline">{\boldsymbol{y}}</span> at time <span class="math inline">t</span>. The following result uses these functions to provide a convenient formula for the total time derivative of a spatial field.</p>
<div id="prp-totaltimederiv" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 5</strong></span> If <span class="math inline">{\boldsymbol{\varphi}}:B\times[0,T]\to{\mathbb{E}}^3</span> is a motion of a continuum body with associated spatial velocity field <span class="math inline">{\boldsymbol{v}}</span>, and <span class="math inline">\phi=\phi({\boldsymbol{y}},t)</span> and <span class="math inline">{\boldsymbol{w}}={\boldsymbol{w}}({\boldsymbol{x}},t)</span> are spatial fields, then <span class="math display">\DDt{\phi} = \frac{\partial}{\partial t} \phi + \nabla_{\boldsymbol{y}}\phi\cdot {\boldsymbol{v}}\quad\text{and}\quad
    \DDt{{\boldsymbol{w}}} = \frac{\partial}{\partial t} {\boldsymbol{w}}+ \big(\nabla_{\boldsymbol{y}}{\boldsymbol{w}}\big) {\boldsymbol{v}}.</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Taking components in a Cartesian frame <span class="math inline">\{{\boldsymbol{e}}_i\}</span>, we have <span class="math display">\nabla_{\boldsymbol{y}}\phi = \frac{\partial \phi}{\partial y_i}{\boldsymbol{e}}_i\quad\text{and}\quad
    \nabla_{\boldsymbol{y}}{\boldsymbol{w}}= \frac{\partial w_i}{\partial y_j}{\boldsymbol{e}}_i\otimes{\boldsymbol{e}}_j.</span> By the definition of the total time derivative, we have <span class="math display">\begin{aligned}
      \DDt{\phi}({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}= {\boldsymbol{\varphi}}({\boldsymbol{x}},t)}
      &amp;= \frac{\partial}{\partial t} \phi({\boldsymbol{\varphi}}({\boldsymbol{x}},t),t)\\
      &amp;= \frac{\partial}{\partial t} \phi({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}= {\boldsymbol{\varphi}}({\boldsymbol{x}},t)}+
      \frac{\partial}{\partial y_i} \phi({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}= {\boldsymbol{\varphi}}({\boldsymbol{x}},t)}\frac{\partial}{\partial t}\varphi_i({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}= {\boldsymbol{\varphi}}({\boldsymbol{x}},t)}\\
      &amp;= \frac{\partial}{\partial t} \phi({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}= {\boldsymbol{\varphi}}({\boldsymbol{x}},t)}+
      \frac{\partial}{\partial y_i} \phi({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}= {\boldsymbol{\varphi}}({\boldsymbol{x}},t)}v_i({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}= {\boldsymbol{\varphi}}({\boldsymbol{x}},t)}.
    \end{aligned}</span> Expressing this result in terms of the spatial coordinates <span class="math inline">{\boldsymbol{y}}</span>, we have the result. Writing <span class="math inline">{\boldsymbol{w}}=w_i{\boldsymbol{e}}_i</span> and applying the same argument to each coordinate, we obtain the result for <span class="math inline">{\boldsymbol{w}}</span>.</p>
</div>
<p><strong>Remarks:</strong></p>
<ul>
<li><p>This result shows that is we know the spatial velocity field <span class="math inline">{\boldsymbol{v}}</span>, then we can compute the total time derivative of a spatial field <span class="math inline">\phi</span> without explicit knowledge of <span class="math inline">{\boldsymbol{\varphi}}</span> or <span class="math inline">{\boldsymbol{\psi}}</span>.</p></li>
<li><p>The spatial acceleration field satisfies <span class="math inline">{\boldsymbol{a}}= \DDt{\boldsymbol{v}}</span>, and so applying <a href="#prp-totaltimederiv" class="quarto-xref">Proposition&nbsp;5</a>, we have <span class="math display">{\boldsymbol{a}}= \frac{\partial{\boldsymbol{v}}}{\partial t} +(\nabla_{\boldsymbol{y}}{\boldsymbol{v}}){\boldsymbol{v}}.</span> The spatial acceleration is therefore a nonlinear function of the spatial velocity and its derivatives.</p></li>
<li><p>Many texts write <span class="math inline">{\boldsymbol{v}}\cdot\nabla_{\boldsymbol{y}}{\boldsymbol{w}}</span> in place of <span class="math inline">(\nabla_{\boldsymbol{y}}{\boldsymbol{w}}){\boldsymbol{v}}</span>, but we prefer our notation here since <span class="math inline">\nabla_{\boldsymbol{y}}{\boldsymbol{w}}</span> is a second-order tensor, and so our notation remains consistent with the usual application of a second-order tensor to a vector.</p></li>
</ul>
</section>
</section>
<section id="rate-of-strain-and-spin" class="level2">
<h2 class="anchored" data-anchor-id="rate-of-strain-and-spin">Rate of strain and spin</h2>
<p>Sometimes, we wish to quantify the rate at which points in a body of interest are distorting. Any measure of the rate of change of shape is called a <em>rate of strain</em>, while any change of orientation is called a <em>rate of rotation</em> or <em>spin</em>. It is important to realise that rates of strain and rotation are independent of the reference configuration <span class="math inline">B</span> (in contrast to measures of strain), since these measures only compare the change of the body over short times. As such, these measures play an important role in the study of fluids.</p>
<p>If <span class="math inline">{\boldsymbol{\varphi}}:B\times[0,T]\to{\mathbb{E}}^3</span> is a motion with spatial velocity field <span class="math inline">{\boldsymbol{v}}</span>, then the <em>rate of strain</em> tensor is <span class="math display">{\boldsymbol{L}}= {\operatorname{sym}}(\nabla_{\boldsymbol{y}}{\boldsymbol{v}}) = \tfrac12\big(\nabla_{\boldsymbol{y}}{\boldsymbol{v}}+(\nabla_{\boldsymbol{y}}{\boldsymbol{v}})^T\big).</span> This is a spatial field <span class="math inline">{\boldsymbol{L}}(\cdot,t):B_t\to{\mathcal{V}}^2</span>, and is symmetric for every point <span class="math inline">{\boldsymbol{y}}\in B_t</span> and each time <span class="math inline">t</span>.</p>
<p>We also define the <em>spin tensor</em> <span class="math display">{\boldsymbol{W}}= {\operatorname{skew}}(\nabla_{\boldsymbol{y}}{\boldsymbol{v}}) = \tfrac12\big(\nabla_{\boldsymbol{y}}{\boldsymbol{v}}-(\nabla_{\boldsymbol{y}}{\boldsymbol{v}})^T\big).</span> This too is a spatial field <span class="math inline">{\boldsymbol{W}}(\cdot,t):B_t\to{\mathcal{V}}^2</span>, which is skew for all points <span class="math inline">{\boldsymbol{y}}\in B_t</span> and times <span class="math inline">t</span>.</p>
<p>We can use arguments analogous to those used to analyse the infinitesimal strain tensor <span class="math inline">{\boldsymbol{E}}</span> to study <span class="math inline">{\boldsymbol{L}}</span>, which leads us to conclude that the diagonal components of <span class="math inline">{\boldsymbol{L}}</span> quantify the instantaneous rate of stretch at a spatial point in the coordinate axis directions. Similarly, the off-diagonal components of <span class="math inline">{\boldsymbol{L}}</span> quantify the instantaneous rate of shearing. In particular, if we consider a motion <span class="math inline">\widehat{\boldsymbol{\varphi}}:B_t\to B_{t+s}</span> where <span class="math inline">s\ll 1</span>, then <span class="math inline">{\boldsymbol{L}}</span> is the rate of change of both the corresponding infinitesimal strain tensor <span class="math inline">\widehat{\boldsymbol{E}}</span> and of the right stretch tensor <span class="math inline">\widehat{\boldsymbol{U}}</span>.</p>
<p>The skew-symmetric tensor <span class="math inline">{\boldsymbol{W}}</span> quantifies the instantaneous rate of rigid rotation. In particular, considering the same motion <span class="math inline">\widehat{\boldsymbol{\varphi}}:B_t\to B_{t+s}</span>, then <span class="math inline">{\boldsymbol{W}}</span> is the rate of change of <span class="math inline">\widehat{\boldsymbol{R}}</span> which is the rotation tensor in the polar decomposition of the deformation gradient <span class="math inline">\nabla_{\boldsymbol{x}}\widehat{\boldsymbol{\varphi}}</span>.</p>
<section id="vorticity" class="level3">
<h3 class="anchored" data-anchor-id="vorticity">Vorticity</h3>
<p>The vorticity of a motion is the spatial vector field <span class="math display">{\boldsymbol{w}}= \nabla_{\boldsymbol{y}}\times{\boldsymbol{v}}.</span> We note that in view of result <strong>?@prp-skewtensorvectorproduct</strong>, <span class="math inline">{\boldsymbol{w}}</span> is the axial vector associated with the (multiple of the) spin tensor <span class="math inline">2{\boldsymbol{W}}</span>. The vorticity therefore measures the rotation or spin at a given spatial point.</p>
</section>
<section id="rigid-motion" class="level3">
<h3 class="anchored" data-anchor-id="rigid-motion">Rigid motion</h3>
<p>A motion <span class="math inline">{\boldsymbol{\varphi}}</span> is <em>rigid</em> if <span class="math display">\varphi({\boldsymbol{x}},t) = {\boldsymbol{c}}(t)+{\boldsymbol{Q}}(t){\boldsymbol{x}}</span> for some time-dependent vector <span class="math inline">{\boldsymbol{c}}(t)</span> and rotation tensor <span class="math inline">{\boldsymbol{Q}}(t)</span>. For such motions it can be shown that the spatial velocity field takes the form <span class="math display">{\boldsymbol{v}}({\boldsymbol{y}},t) = \bfomega(t)\times\big({\boldsymbol{y}}-{\boldsymbol{c}}(t)\big)+\dot{{\boldsymbol{c}}}(t),</span> where <span class="math inline">\bfomega(t)</span> is a time-dependent vector called the <em>spatial angular velocity</em> of the motion and <span class="math inline">\dot{{\boldsymbol{c}}}</span> indicates a time derivative. We can use <strong>?@prp-skewtensorvectorproduct</strong> to write this as <span class="math display">{\boldsymbol{v}}({\boldsymbol{y}},t) = \bfOmega(t)\big({\boldsymbol{y}}-{\boldsymbol{c}}(t)\big)+\dot{\boldsymbol{c}}(t),</span> where <span class="math inline">\bfOmega(t)</span> is the second-order tensor with axial vector <span class="math inline">\bfomega(t)</span>. It follows that <span class="math display">\nabla_{\boldsymbol{y}}{\boldsymbol{v}}({\boldsymbol{y}},t) = \bfOmega(t),</span> from which we deduce <span class="math inline">{\boldsymbol{L}}= {\boldsymbol{O}}</span>, <span class="math inline">{\boldsymbol{W}}= \bfOmega(t)</span>, and <span class="math inline">{\boldsymbol{w}}= 2\bfomega(t)</span>. It follows that rigid motions produce no rate of strain measured by <span class="math inline">{\boldsymbol{L}}</span>, but do produce spin as measured by the spin <span class="math inline">{\boldsymbol{W}}</span> or vorticity <span class="math inline">{\boldsymbol{w}}</span>.</p>
</section>
</section>
<section id="change-of-variables" class="level2">
<h2 class="anchored" data-anchor-id="change-of-variables">Change of variables</h2>
<p>As we saw in the previous chapter, it is useful to express various physical quantities as integrals. However, we now have two sets of coordinates to integrate with respect to: the material coordinates <span class="math inline">{\boldsymbol{x}}\in B</span>, and the spatial coordinates <span class="math inline">{\boldsymbol{y}}\in B_t</span>. For fixed <span class="math inline">t</span>, the mappings <span class="math inline">{\boldsymbol{\varphi}}(\cdot,t)</span> and <span class="math inline">{\boldsymbol{\psi}}(\cdot,t)</span> act as changes of variable between these two sets of coordinates.</p>
<section id="transformation-of-volume-integrals" class="level3">
<h3 class="anchored" data-anchor-id="transformation-of-volume-integrals">Transformation of volume integrals</h3>
<p>As you will have seen in multivariable calculus modules, we can express the volume element in the spatial coordinates, <span class="math inline">dV_{\boldsymbol{y}}</span>, in terms of material coordinates <span class="math inline">{\boldsymbol{x}}</span> by considering the volume change transformation of an infinitesimal cube at a fixed material point. This volume change factor is given by the <em>Jacobian (determinant)</em> of the transformation, which in the case of <span class="math inline">{\boldsymbol{y}}= {\boldsymbol{\varphi}}({\boldsymbol{x}},t)</span> is <span class="math display">\det(\nabla_{\boldsymbol{x}}{\boldsymbol{\varphi}}({\boldsymbol{x}},t))=\det{\boldsymbol{F}}({\boldsymbol{x}},t),</span> and hence <span class="math inline">{\,{\mathrm{d}}V_{{\boldsymbol{y}}}}= \det{\boldsymbol{F}}({\boldsymbol{x}},t){\,{\mathrm{d}}V_{{\boldsymbol{x}}}}</span>. This leads to the following change of variable formula for volume integrals.</p>
<div id="prp-TransformationOfVolumeIntegrals" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 6</strong></span> If <span class="math inline">\phi({\boldsymbol{y}},t)</span> is a spatial scalar field defined on <span class="math inline">B_t</span>, and let <span class="math inline">\Omega_t\subset B_t</span>, with <span class="math inline">\Omega = {\boldsymbol{\psi}}(\Omega_t,t)\subset B</span>. Then <span class="math display">\int_{\Omega_t}\phi({\boldsymbol{y}},t){\,{\mathrm{d}}V_{{\boldsymbol{y}}}}= \int_\Omega \phi_m({\boldsymbol{x}},t)\det{\boldsymbol{F}}({\boldsymbol{x}},t){\,{\mathrm{d}}V_{{\boldsymbol{x}}}}.</span></p>
</div>
<p><strong>Remarks:</strong></p>
<ol type="1">
<li><p>By arguments similar to those applied to the expressions of the Divergence Theorem and Stokes’ Theorem, we can use the change of variable formula to show that <span class="math display">\det {\boldsymbol{F}}({\boldsymbol{x}}_0,t) = \lim_{\delta\to 0} \frac{{\operatorname{vol}}(\Omega_{\delta,t})}{{\operatorname{vol}}(\Omega_{\delta,0})},</span> where <span class="math inline">\Omega_{\delta,0}</span> is a ball of radius <span class="math inline">\delta</span> centred at <span class="math inline">{\boldsymbol{x}}_0\in B</span>, and <span class="math inline">\Omega_{\delta,t} = {\boldsymbol{\varphi}}(\Omega_{\delta,0},t)</span> is the image of the set after deformation. This means that the determinant of the deformation gradient measures the volume change due to deformation at a fixed material point.</p></li>
<li><p>The field <span class="math inline">J({\boldsymbol{x}},t) = \det {\boldsymbol{F}}({\boldsymbol{x}},t)</span> is called the Jacobian field of a deformation, and is a measure of the <em>volumetric strain</em> at a material point <span class="math inline">{\boldsymbol{x}}\in B</span> and time <span class="math inline">t</span>. If <span class="math inline">J({\boldsymbol{x}},t)&gt;1</span>, the material volume has expanded, while if <span class="math inline">J({\boldsymbol{x}},t)&lt;1</span>, the material volume has contracted.</p></li>
</ol>
<p>The latter remark leads us to define a <em>volume-preserving</em> or <em>isochoric</em> motion to be any motion such that <span class="math inline">{\operatorname{vol}}({\boldsymbol{\varphi}}(\Omega,t))={\operatorname{vol}}(\Omega)</span> for all open subsets <span class="math inline">\Omega\subset B</span>, and in this case, we have the following result:</p>
<div id="prp-volumepreserving" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 7</strong></span> Suppose <span class="math inline">{\boldsymbol{\varphi}}:B\times[0,T]\to{\mathbb{E}}^3</span> is a motion with spatial velocity field <span class="math inline">{\boldsymbol{v}}</span> and deformation gradient <span class="math inline">{\boldsymbol{F}}</span>. Then <span class="math inline">{\boldsymbol{\varphi}}</span> is volume-preserving in the sense above if and only if <span class="math inline">\det{\boldsymbol{F}}({\boldsymbol{x}},t) = 1</span> for all <span class="math inline">{\boldsymbol{x}}\in B</span> and <span class="math inline">t\in[0,T]</span>, or equivalently, <span class="math display">\nabla_{\boldsymbol{y}}\cdot{\boldsymbol{v}}({\boldsymbol{y}},t) = 0\quad\text{for all }{\boldsymbol{y}}\in B_t\text{ and }t\in[0,T].</span></p>
</div>
<p>We note that simple translations and rotations are volume-preserving since they produce no distortion, but motions which do distort a body can also be volume-preserving.</p>
</section>
<section id="derivatives-of-time-dependent-integrals" class="level3">
<h3 class="anchored" data-anchor-id="derivatives-of-time-dependent-integrals">Derivatives of time-dependent integrals</h3>
<p>We sometimes need to compute the time derivative of a spatial integral, and for this, the following result is useful.</p>
<div id="prp-TotalDerivativeDetF" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 8</strong></span> If <span class="math inline">{\boldsymbol{\varphi}}:B\times [0,T]\to{\mathbb{E}}^3</span> is a motion with spatial velocity field <span class="math inline">{\boldsymbol{v}}({\boldsymbol{y}},t)</span> and deformation gradient <span class="math inline">{\boldsymbol{F}}({\boldsymbol{x}},t)</span>, then <span class="math display">\frac{\partial}{\partial t}\det{\boldsymbol{F}}({\boldsymbol{x}},t) = \det{\boldsymbol{F}}({\boldsymbol{x}},t)(\nabla_{\boldsymbol{y}}\cdot{\boldsymbol{v}})({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}={\boldsymbol{\varphi}}({\boldsymbol{x}},t)}.</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Using <strong>?@prp-derivativedet</strong> and the chain rule, we have <span id="eq-dotdet"><span class="math display">
    \frac{\partial}{\partial t}\det{\boldsymbol{F}}({\boldsymbol{x}},t) = \det{\boldsymbol{F}}({\boldsymbol{x}},t) {\operatorname{tr}}\bigg({\boldsymbol{F}}({\boldsymbol{x}},t)^{-1}\frac{\partial}{\partial t}{\boldsymbol{F}}({\boldsymbol{x}},t)\bigg),
\tag{2}</span></span> and the components of the spatial velocity field satisfy <span class="math display">v_i({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}={\boldsymbol{\varphi}}({\boldsymbol{x}},t)} = \frac{\partial}{\partial t}\varphi_i({\boldsymbol{x}},t).</span> Our aim is now to express the trace term in <a href="#eq-dotdet" class="quarto-xref">Equation&nbsp;2</a> in terms of <span class="math inline">{\boldsymbol{v}}</span>. Notice that <span class="math display">F_{ij}({\boldsymbol{x}},t) = \frac{\partial \varphi_i}{\partial x_j}({\boldsymbol{x}},t),</span> so differentiating in time, <span class="math display">\begin{aligned}
    \frac{\partial F_{ij}}{\partial t}({\boldsymbol{x}},t) = \frac{\partial}{\partial t} \frac{\partial \varphi_i}{\partial x_j}({\boldsymbol{x}},t) &amp;= \frac{\partial}{\partial x_j} \frac{\partial \varphi_i}{\partial t}({\boldsymbol{x}},t) \\
    &amp;= \frac{\partial}{\partial x_j}{\boldsymbol{v}}({\boldsymbol{\varphi}}({\boldsymbol{x}},t),t)\\
    &amp;= \frac{\partial}{\partial y_k}{\boldsymbol{v}}({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}={\boldsymbol{\varphi}}({\boldsymbol{x}},t)}\frac{\partial \varphi_k}{\partial x_j}({\boldsymbol{x}},t)\\
    &amp;= \frac{\partial}{\partial y_k}{\boldsymbol{v}}({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}={\boldsymbol{\varphi}}({\boldsymbol{x}},t)}F_{kj}({\boldsymbol{x}},t)
  \end{aligned}</span> In tensor notation, we have shown that <span class="math display">\frac{\partial}{\partial t}{\boldsymbol{F}}({\boldsymbol{x}},t) = \nabla_{\boldsymbol{y}}{\boldsymbol{v}}({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}={\boldsymbol{\varphi}}({\boldsymbol{x}},t)}{\boldsymbol{F}}({\boldsymbol{x}},t),</span> so multiplying by <span class="math inline">{\boldsymbol{F}}^{-1}</span> on the right and taking the trace, we have <span class="math display">{\operatorname{tr}}\bigg(\frac{\partial}{\partial t}{\boldsymbol{F}}({\boldsymbol{x}},t){\boldsymbol{F}}^{-1}({\boldsymbol{x}},t)\bigg) =
  {\operatorname{tr}}\big(\nabla_{\boldsymbol{y}}{\boldsymbol{v}}({\boldsymbol{y}},t)\big)\bigg|_{{\boldsymbol{y}}= {\boldsymbol{\varphi}}({\boldsymbol{x}},t)} = \nabla_{\boldsymbol{y}}\cdot {\boldsymbol{v}}({\boldsymbol{y}},t)\bigg|_{{\boldsymbol{y}}= {\boldsymbol{\varphi}}({\boldsymbol{x}},t)}.</span> We can now conclude by using this expression in <a href="#eq-dotdet" class="quarto-xref">Equation&nbsp;2</a>, and noting that <span class="math inline">{\operatorname{tr}}({\boldsymbol{A}}{\boldsymbol{B}})={\operatorname{tr}}({\boldsymbol{B}}{\boldsymbol{A}})</span> for any two tensors <span class="math inline">{\boldsymbol{A}},{\boldsymbol{B}}\in{\mathcal{V}}^2</span>.</p>
</div>
<p>This result shows that the time derivative of the Jacobian field depends only upon the field itself and the divergence of the spatial velocity. This leads to the following famous result.</p>
<div id="prp-Reynolds" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 9 (Reynolds’ Transport Theorem)</strong></span> Suppose <span class="math inline">{\boldsymbol{\varphi}}:B\times[0,T]\to{\mathbb{E}}^3</span> is a motion with an associated spatial velocity field <span class="math inline">{\boldsymbol{v}}</span>. Let <span class="math inline">\Omega_t\subset B_t</span> be an arbitrary volume with boundary <span class="math inline">\partial \Omega_t</span> which has outward normal field <span class="math inline">{\boldsymbol{n}}</span>. Then for any spatial scalar field <span class="math inline">\phi</span> we have <span class="math display">\DDt{}\int_{\Omega_t}\phi{\,{\mathrm{d}}V_{{\boldsymbol{y}}}}= \int_{\Omega_t}\DDt{\phi}+\phi(\nabla_{\boldsymbol{y}}\cdot{\boldsymbol{v}}){\,{\mathrm{d}}V_{{\boldsymbol{y}}}},</span> or equivalently <span class="math display">\DDt{}\int_{\Omega_t}\phi{\,{\mathrm{d}}V_{{\boldsymbol{y}}}}= \int_{\Omega_t}\frac{\partial \phi}{\partial t}{\,{\mathrm{d}}V_{{\boldsymbol{y}}}}+\int_{\partial \Omega_t}\phi {\boldsymbol{v}}\cdot{\boldsymbol{n}}{\,{\mathrm{d}}A_{{\boldsymbol{y}}}}.</span></p>
</div>
<p><strong>Remarks:</strong></p>
<ol type="1">
<li><p>Once more, this theorem shows that if the spatial velocity <span class="math inline">{\boldsymbol{v}}</span> is known, then the time derivative of a volume integral over any subset <span class="math inline">\Omega_t\subset B_t</span> can be determined without explicit knowledge of <span class="math inline">{\boldsymbol{\varphi}}</span> or its inverse <span class="math inline">{\boldsymbol{\psi}}</span>.</p></li>
<li><p>The fact this is called a ‘transport theorem’ is motivated by the second equality. The first term on the RHS is the change of the field <span class="math inline">\phi</span> in the volume <span class="math inline">\Omega_t</span>, while the second term reflect the amount of <span class="math inline">\phi</span> which is transported across the boundary <span class="math inline">\partial \Omega_t</span>, as determined by the normal component of the velocity <span class="math inline">{\boldsymbol{v}}\cdot{\boldsymbol{n}}</span>.</p></li>
</ol>
</section>
<section id="transformation-of-surface-integrals" class="level3">
<h3 class="anchored" data-anchor-id="transformation-of-surface-integrals">Transformation of surface integrals</h3>
<p>Along with volume integrals, we also consider how surface integrals transform under the mapping from the reference configuration to the deformed configuration. Suppose that <span class="math inline">\Gamma\subset B</span> is a referential surface with a unit normal field <span class="math inline">{\boldsymbol{\nu}}:\Gamma\to{\mathcal{V}}</span>, and let <span class="math inline">\gamma_t = {\boldsymbol{\varphi}}(\Gamma,t)</span> be the corresponding surface in the deformed configuration, with accompanying normal field <span class="math inline">{\boldsymbol{n}}:\gamma_t\to{\mathcal{V}}</span>.</p>
<p>It can be shown that in this case that the oriented surface area element satisfies <span class="math display">{\boldsymbol{n}}({\boldsymbol{y}}){\,{\mathrm{d}}A_{{\boldsymbol{y}}}}= {\operatorname{cof}}\big({\boldsymbol{F}}({\boldsymbol{x}},t)\big){\boldsymbol{\nu}}({\boldsymbol{x}}){\,{\mathrm{d}}A_{{\boldsymbol{x}}}}.</span> The argument is similar to that made for a transformation of surface integrals, but since it is relatively technical, we omit it. This leads us to the following result.</p>
<div class="proposition">
<p>Suppose <span class="math inline">\phi</span>, <span class="math inline">{\boldsymbol{w}}</span>, and <span class="math inline">{\boldsymbol{T}}</span> are spatial scalar, vector and tensor fields, and that <span class="math inline">\Omega\subset B</span> is a subset which is mapped to <span class="math inline">\Omega_t = {\boldsymbol{\varphi}}(B,t)\subset B_t</span> under the motion <span class="math inline">{\boldsymbol{\varphi}}</span>, where <span class="math inline">\partial \Omega\subset B</span> has outward-pointing normal field <span class="math inline">{\boldsymbol{\nu}}</span>, and <span class="math inline">\partial\Omega_t\subset B_t</span> has outward-pointing normal field <span class="math inline">{\boldsymbol{n}}</span>. Then <span class="math display">\begin{aligned}
      \int_{\partial\Omega_t}\phi({\boldsymbol{y}},t){\boldsymbol{n}}({\boldsymbol{y}}){\,{\mathrm{d}}A_{{\boldsymbol{y}}}}&amp;= \int_{\partial\Omega}\phi_m({\boldsymbol{x}},t){\operatorname{cof}}{\boldsymbol{F}}({\boldsymbol{x}},t){\boldsymbol{\nu}}({\boldsymbol{x}}){\,{\mathrm{d}}A_{{\boldsymbol{x}}}}\\
      \int_{\partial\Omega_t}{\boldsymbol{w}}({\boldsymbol{y}},t)\cdot {\boldsymbol{n}}({\boldsymbol{y}}){\,{\mathrm{d}}A_{{\boldsymbol{y}}}}&amp;= \int_{\partial\Omega}{\boldsymbol{w}}_m({\boldsymbol{x}},t)\cdot\big({\operatorname{cof}}{\boldsymbol{F}}({\boldsymbol{x}},t){\boldsymbol{\nu}}({\boldsymbol{x}})\big){\,{\mathrm{d}}A_{{\boldsymbol{x}}}}\\
      \int_{\partial\Omega_t}{\boldsymbol{T}}({\boldsymbol{y}},t){\boldsymbol{n}}({\boldsymbol{y}}){\,{\mathrm{d}}A_{{\boldsymbol{y}}}}&amp;= \int_{\partial\Omega}{\boldsymbol{T}}_m({\boldsymbol{x}},t){\operatorname{cof}}{\boldsymbol{F}}({\boldsymbol{x}},t){\boldsymbol{\nu}}({\boldsymbol{x}}){\,{\mathrm{d}}A_{{\boldsymbol{x}}}},
    \end{aligned}</span> where we recall that the cofactor tensor (as previously defined in the statement of Proposition&nbsp;<a href="#prop:derivativedet" data-reference-type="ref" data-reference="prop:derivativedet">[prop:derivativedet]</a>) is defined to be <span class="math display">{\operatorname{cof}}({\boldsymbol{F}}) = (\det{\boldsymbol{F}}){\boldsymbol{F}}^{-T}.</span></p>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>